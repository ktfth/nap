#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const isTTY = process.stdin.isTTY;
const isPipe = !isTTY;
const { Transform } = require('stream');
const args = process.argv.slice(2);
const nap = require('../');
let searchData = null;

if (isPipe) {
    searchData = nap.searchDataTransform(args);
    process.stdin.pipe(searchData).pipe(process.stdout);
    process.stdin.resume();
} else if ((!isPipe && (isTTY)) && args.length) {
    searchData = nap.searchDataTransform(args);
    let traversalSearch = dir => {
        let limit = 0
        let directory = fs.readdirSync(dir, {
            withFileTypes: true
        });
        let _cacheDirectory = [];
        let _cacheDirectories = [];
        if (directory) {
            _cacheDirectory = directory.filter(dirent => {
                return dirent.isFile() && !(dirent.name.indexOf('.') === 0);
            });

            let processPipeline = filePath => {
                if (fs.existsSync(filePath)) {
                    let fileStream = fs.createReadStream(filePath);
                    return fileStream;
                } else {
                    return null;
                }
            };

            for (let i = 0, l = _cacheDirectory.length; i < l; i += 1) {
              let file = _cacheDirectory[i];
              let filePath = path.resolve(process.cwd(), file.name);
              let fileStream = processPipeline(filePath);
              if (fileStream) {
                  fileStream.pipe(searchData).pipe(process.stdout);
                  setTimeout(() => {
                      fileStream.close();
                      fileStream.push(null);
                      fileStream.read(0);
                  }, 100);
              }
            }

            if (limit < 3) {
                _cacheDirectories = directory.filter(dirent => {
                    return dirent.isDirectory() && !(dirent.name.indexOf('.') === 0);
                })

                for (let i = 0, l = _cacheDirectories.length; i < l; i += 1) {
                    let directory = _cacheDirectories[i];
                    let access = path.resolve(dir, directory.name);
                    if (fs.existsSync(access)) {
                      return traversalSearch(access);
                    }
                }

                limit += 1;
            }
        }
    };
    traversalSearch(process.cwd());
}
