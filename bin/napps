#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const isTTY = process.stdin.isTTY;
const isPipe = !isTTY;
const { Transform } = require('stream');
const args = process.argv.slice(2);
const nap = require('../');
const _argSep = nap.argSep;
const package = require('../package.json');

process.stdin.setEncoding('utf8');

process.stdout.setMaxListeners(100000);

if (isPipe) {
    searchData = nap.searchDataTransform(args);
    process.stdin.pipe(searchData).pipe(process.stdout);
} else if ((!isPipe && (isTTY)) && args.length) {
    let filterDirectory = nap.filterDirectory;

    let filterIsDirectory = nap.filterIsDirectory;

    let filterExclude = nap.filterExclude;

    let excludesMap = nap.excludesMap;

    let renderPipeline = (filePath) => {
        let fileStream = fs.createReadStream(filePath);
        fileStream.setMaxListeners(100000);
        fileStream
          .pipe(nap.traversalSearchDataTransform(args, filePath))
          .pipe(process.stdout);
        return fileStream;
    };

    let singlePipeline = (args, filePath, excludes) => {
        if (!excludes.length) {
          renderPipeline(filePath);
        }
    };

    let mulPipeline = (args, filePath, excludes) => {
        return excludes.map(v => {
            if (filePath.indexOf(v[1]) === -1) {
                renderPipeline(filePath);
            }

            return v;
        });
    };

    let traverse = (access, _cacheDirectories) => {
      if (fs.existsSync(access)) {
          traversalSearch(access, _cacheDirectories);
      }
    };
    // searchData = nap.searchDataTransform(args);
    let traversalSearch = (dir, dirs=[]) => {
        let limit = 0;
        let directory = fs.readdirSync(dir, {
            withFileTypes: true
        });
        let _cacheDirectory = [];
        let _cacheDirectories = dirs;
        if (directory) {
            _cacheDirectory = filterDirectory(directory);

            _cacheDirectories = filterIsDirectory(directory);

            for (let i = 0, l = _cacheDirectory.length; i < l; i += 1) {
              let file = _cacheDirectory[i];
              let filePath = path.resolve(dir, file.name);
              let excludes = filterExclude(args);

              excludes = excludesMap(excludes);

              singlePipeline(args, filePath, excludes);
              mulPipeline(args, filePath, excludes);
            }

            if (limit < 1000) {
                for (let i = 0, l = _cacheDirectories.length; i < l; i += 1) {
                    let directory = _cacheDirectories[i];
                    let access = path.resolve(dir, directory.name);
                    traverse(access, _cacheDirectories);
                    limit += 1;
                }
            }
        }
    };
    traversalSearch(process.cwd());
} else {
    console.log(package.name + ':', package.version, '\n');
    console.log('default behavior: ', 'count presence of any term ' +
                'present as argument\n');
    console.log('--extract', ' - ', 'Show content as output founded by term');
    console.log('--exclude', ' - ', 'Receive an value to act like the ' +
                'definition of parameter');
    console.log('--re', ' - ', 'Accept regular expression, combined');
    console.log('--rev', ' - ', 'Reverse the output');
}
